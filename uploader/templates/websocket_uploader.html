{% macro file_field_ws(name, label, help_text="", toggle=false, mode_toggle=false) %}
<div class="form-group">
    <div class="form-section directory-upload-container">
        <h2>üìÇ Directory Upload (WebSocket)</h2>
        <h3>For Large Directory Structures (20GB+)</h3>
        <p>This section uses WebSocket technology to handle large directory uploads while preserving the folder structure.</p>
        
        <div class="file-input-container" id="dropZone">
            <p>Click to select directories or drag and drop them here</p>
            <input type="file" id="directoryInput" webkitdirectory multiple style="display: none;">
            <button type="button" class="upload-button" onclick="document.getElementById('directoryInput').click()">
                Select Directories
            </button>
        </div>
        
        <div id="fileList" class="file-list" style="display: none;"></div>
        
        <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p id="progressText">Preparing upload...</p>
        </div>
        
        <button type="button" id="startWebSocketUpload" class="upload-button" style="display: none;" onclick="startDirectoryUpload()">
            Start Directory Upload
        </button>
        
        <div id="statusMessages"></div>
        
        {% if help_text %}
            <small class="form-help">{{ help_text }}</small>
        {% endif %}
        {% if mode_toggle %}
        
            
        <div class="overwrite-option">
            <label class="checkbox-label">
                <input type="checkbox" id="{{ name }}_overwrite" name="{{ name }}_mode" value="replace" data-websocket-overwrite="true">
                <span class="checkbox-text">Overwrite?</span>
            </label>
        </div>
        <small class="overwrite-disclaimer">‚ö†Ô∏è Checking "Overwrite" will replace all existing files of this type. Leave unchecked to add to existing files.</small>
        {% endif %}
    </div>
    
    {% if help_text %}
        <small class="form-help">{{ help_text }}</small>
    {% endif %}

    {% if toggle %}
        <div class="toggle-help">
            <input type="checkbox" id="{{ name }}_toggle" onchange="document.getElementById('{{ name }}').disabled = !this.checked;">
            <label for="{{ name }}_toggle">Enable file upload</label>
        </div>
        <script>
            document.getElementById('{{ name }}').disabled = true;
        </script>
    {% endif %}
</div>
{% endmacro %}

{% macro websocket_upload_script(upload_endpoint="/ws/upload",
                                experiment_name_input_id="experiment_name",
                                upload_button_id="uploadButton", 
                                progress_container_id="progressContainer", 
                                status_messages_id="statusMessages", 
                                directory_input_id="directoryInput") %}
<script>
let selectedFiles = [];
let websocket = null;
let uploadId = null;
let directoryUploadCompleted = false;

// Define protocol for WebSocket connection
const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';

// Generate unique upload ID
function generateUploadId() {
    return 'upload_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
}

// Handle directory selection (WebSocket upload only)
document.getElementById('{{ directory_input_id }}').addEventListener('change', function(event) {
    selectedFiles = Array.from(event.target.files);
    
    // Filter to only include image files
    const imageFiles = selectedFiles.filter(file => {
        const ext = file.name.split('.').pop().toLowerCase();
        return ['tif', 'tiff', 'png', 'jpg', 'jpeg'].includes(ext);
    });
    // filter files that are not included in a directory (those that do not have a relativepath )
    const dirFiles = imageFiles.filter(file => {
        return file.webkitRelativePath && file.webkitRelativePath !== file.name;
    });

    if (dirFiles.length !== selectedFiles.length) {
        const filteredCount = selectedFiles.length - dirFiles.length;
        addStatusMessage(`Note: ${filteredCount} non-directory/non-image files will be excluded from upload. Only directory files will be uploaded.`, 'warning');
    }
    
    selectedFiles = dirFiles;
    displaySelectedFiles();
    
    // Show/hide the start upload button
    const startButton = document.getElementById('startWebSocketUpload');
    if (selectedFiles.length > 0) {
        startButton.style.display = 'block';
    } else {
        startButton.style.display = 'none';
    }
});

// Display selected files for directory upload
function displaySelectedFiles() {
    const fileList = document.getElementById('fileList');
    const totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);
    
    if (selectedFiles.length === 0) {
        fileList.style.display = 'none';
        return;
    }
    
    const fileListHTML = selectedFiles.slice(0, 20).map(file => 
        `<div class="file-item">${file.webkitRelativePath} (${formatFileSize(file.size)})</div>`
    ).join('');
    
    const additionalFiles = selectedFiles.length > 20 ? 
        `<div class="file-item"><em>... and ${selectedFiles.length - 20} more files</em></div>` : '';
    
    fileList.innerHTML = 
        `<strong>Selected files (${selectedFiles.length}) - Total: ${formatFileSize(totalSize)}:</strong><br>` +
        fileListHTML + additionalFiles;
    fileList.style.display = 'block';
}

// Format file size
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Add status message for directory upload
function addStatusMessage(message, type = 'info') {
    const statusDiv = document.getElementById('{{ status_messages_id }}');
    const messageDiv = document.createElement('div');
    messageDiv.className = `status ${type}`;
    messageDiv.textContent = message;
    statusDiv.appendChild(messageDiv);
    
    if (type === 'info' || type === 'warning') {
        setTimeout(() => {
            if (messageDiv.parentNode) {
                messageDiv.parentNode.removeChild(messageDiv);
            }
        }, 5000);
    }
}

// Start directory upload process (WebSocket)
async function startDirectoryUpload() {
    const uploadNameInput = document.getElementById('{{ experiment_name_input_id }}');
    const uploadName = uploadNameInput ? uploadNameInput.value.trim() : '';
    
    if (!uploadName) {
        addStatusMessage('Please enter an experiment name before uploading directories.', 'error');
        uploadNameInput.focus();
        return;
    }
    
    if (selectedFiles.length === 0) {
        addStatusMessage('Please select directories to upload.', 'error');
        return;
    }

    // Get overwrite flag from the specific WebSocket upload checkbox
    // Default to false if mode_toggle is not enabled or checkbox doesn't exist
    const overwriteCheckbox = document.querySelector('input[data-websocket-overwrite="true"]');
    const overwriteMode = overwriteCheckbox ? overwriteCheckbox.checked : false;
    
    console.log('WebSocket overwrite checkbox found:', !!overwriteCheckbox); // Debug log
    console.log('WebSocket overwrite checkbox checked:', overwriteCheckbox ? overwriteCheckbox.checked : 'N/A'); // Debug log
    console.log('WebSocket overwrite mode:', overwriteMode); // Debug log

    // Show progress container and hide start button
    document.getElementById('{{ progress_container_id }}').style.display = 'block';
    document.getElementById('startWebSocketUpload').style.display = 'none';

    uploadId = generateUploadId();
    // Send the upload name and overwrite flag as query parameters
    const wsUrl = `${protocol}//${window.location.host}{{ upload_endpoint }}/${uploadId}?upload_name=${encodeURIComponent(uploadName)}&overwrite=${overwriteMode}`;
    
    console.log('WebSocket URL:', wsUrl); // Debug log
    
    websocket = new WebSocket(wsUrl);
    
    websocket.onopen = function() {
        addStatusMessage('Connected to server, starting directory upload...', 'info');
    };
    
    websocket.onmessage = async function(event) {
        const data = JSON.parse(event.data);
        
        switch(data.type) {
            case 'ready':
                addStatusMessage('Server ready, uploading files...', 'info');
                await uploadFiles();
                break;
            
            case 'progress':
                updateProgress(data);
                break;
            
            case 'complete':
                handleUploadComplete(data);
                break;
            
            case 'error':
                addStatusMessage(data.message, 'error');
                resetUpload();
                break;
        }
    };
    
    websocket.onerror = function(error) {
        addStatusMessage('WebSocket error occurred', 'error');
        resetUpload();
    };
    
    websocket.onclose = function() {
        if (!directoryUploadCompleted) {
            addStatusMessage('WebSocket connection closed unexpectedly', 'error');
        }
    };
}

// Upload files via WebSocket
async function uploadFiles() {
    for (let i = 0; i < selectedFiles.length; i++) {
        const file = selectedFiles[i];
        
        try {
            const content = await fileToBase64(file);
            websocket.send(JSON.stringify({
                type: 'file',
                path: file.webkitRelativePath,
                content: content.split(',')[1] // Remove data:mime;base64, prefix
            }));
        } catch (error) {
            addStatusMessage(`Error uploading ${file.name}: ${error.message}`, 'error');
        }
    }
    
    websocket.send(JSON.stringify({
        type: 'complete'
    }));
}

// Convert file to base64
function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
    });
}

// Update progress display
function updateProgress(data) {
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    
    const percentage = (data.files_received / selectedFiles.length) * 100;
    progressFill.style.width = `${percentage}%`;
    
    progressText.textContent = 
        `Uploaded ${data.files_received} of ${selectedFiles.length} files ` +
        `(${formatFileSize(data.total_size)}) - Current: ${data.current_file}`;
}

// Handle upload completion
function handleUploadComplete(data) {
    directoryUploadCompleted = true;
    
    // Mark WebSocket upload as completed
    document.getElementById('websocket_upload_completed').value = 'true';
    
    addStatusMessage(
        `Directory upload completed! ${data.files_received} files uploaded ` +
        `(${formatFileSize(data.total_size)}) to ${data.upload_dir}`, 
        'success'
    );
    
    // Store webkitRelativePath information
    storeRawImagePaths(selectedFiles);
    
    // Reset upload state but keep the success message
    resetUploadState();
}

// Reset upload state
function resetUploadState() {
    document.getElementById('{{ progress_container_id }}').style.display = 'none';
    document.getElementById('startWebSocketUpload').style.display = 'none';
    
    if (websocket) {
        websocket.close();
        websocket = null;
    }
}

// Reset upload (for errors)
function resetUpload() {
    resetUploadState();
    document.getElementById('startWebSocketUpload').style.display = selectedFiles.length > 0 ? 'block' : 'none';
    directoryUploadCompleted = false;
    // Reset completion flag
    document.getElementById('websocket_upload_completed').value = 'false';
}

// Store webkitRelativePath information for each file
function storeRawImagePaths(files) {
    const pathsData = [];
    files.forEach((file, index) => {
        if (file.webkitRelativePath) {
            pathsData.push({
                filename: file.name,
                relativePath: file.webkitRelativePath,
                index: index
            });
        }
    });
    
    console.log(`Storing paths for ${pathsData.length} files`);
    
    // Store in the hidden input field
    const pathsInput = document.getElementById('raw_image_paths');
    if (pathsInput) {
        const jsonData = JSON.stringify(pathsData);
        pathsInput.value = jsonData;
        console.log('Stored raw image paths:', pathsData);
    } else {
        console.error('Could not find raw_image_paths input field');
    }
}

//

// Enhanced drag and drop for regular file inputs
document.querySelectorAll('.file-input-container').forEach(container => {
    const input = container.querySelector('input[type="file"]');
    
    if (input && input.id !== '{{ directory_input_id }}') {
        container.addEventListener('dragover', function(e) {
            e.preventDefault();
            container.classList.add('dragover');
        });
        
        container.addEventListener('dragleave', function(e) {
            e.preventDefault();
            container.classList.remove('dragover');
        });
        
        container.addEventListener('drop', function(e) {
            e.preventDefault();
            container.classList.remove('dragover');
            
            if (e.dataTransfer.files.length > 0) {
                input.files = e.dataTransfer.files;
                
                // Trigger change event
                const event = new Event('change', { bubbles: true });
                input.dispatchEvent(event);
            }
        });
    }
});

// Directory upload drag and drop (special handling)
const directoryDropZone = document.getElementById('dropZone');
if (directoryDropZone) {
    directoryDropZone.addEventListener('dragover', function(e) {
        e.preventDefault();
        directoryDropZone.classList.add('dragover');
    });
    
    directoryDropZone.addEventListener('dragleave', function(e) {
        e.preventDefault();
        directoryDropZone.classList.remove('dragover');
    });
    
    directoryDropZone.addEventListener('drop', function(e) {
        e.preventDefault();
        directoryDropZone.classList.remove('dragover');
        
        // Note: Drag and drop doesn't support webkitdirectory
        addStatusMessage('Please use the "Select Directories" button to choose directories.', 'info');
    });
}

// Modify the main form submission to check if WebSocket upload is needed
function checkWebSocketUploadBeforeSubmit() {
    const hasFiles = selectedFiles && selectedFiles.length > 0;
    const isCompleted = document.getElementById('websocket_upload_completed').value === 'true';
    
    if (hasFiles && !isCompleted) {
        addStatusMessage('Please complete the directory upload first by clicking "Start Directory Upload".', 'warning');
        return false;
    }
    return true;
}

// Override the main form submit handler
const originalHandleSubmit = window.handleSubmit;
window.handleSubmit = function(event) {
    if (!checkWebSocketUploadBeforeSubmit()) {
        event.preventDefault();
        return false;
    }
    
    if (originalHandleSubmit) {
        return originalHandleSubmit(event);
    }
    
    return true;
};
</script>
{% endmacro %}