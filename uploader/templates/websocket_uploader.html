{% macro file_field_ws(name, label, help_text="", toggle=false, mode_toggle=false) %}
<div class="form-group">
    <div class="form-section directory-upload-container">
        <h2 style="text-align: center;">Upload Raw Images (Optional)</h2>
        <h3 style="text-align: center;">Upload raw image directories with either single-image TIFF files or Andor Spool files. Timestamps will be inferred from directory names/Andor metadata.</h3>
        
        
        
        <div class="file-input-container" id="dropZone">
            <p>Click to select directories or drag and drop them here</p>
            <input type="file" id="directoryInput" webkitdirectory multiple style="display: none;">
            <button type="button" class="upload-button" onclick="document.getElementById('directoryInput').click()">
                Select Directories
            </button>
        </div>
        
        <div id="fileList" class="file-list" style="display: none;"></div>
        
        <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p id="progressText">Preparing upload...</p>
        </div>
        

        
        <div id="statusMessages"></div>
        
        {% if help_text %}
            <small class="form-help">{{ help_text }}</small>
        {% endif %}
        {% if mode_toggle %}
        
            
        <div class="overwrite-option">
            <label class="checkbox-label">
                <input type="checkbox" id="{{ name }}_overwrite" name="{{ name }}_mode" value="replace" data-websocket-overwrite="true">
                <span class="checkbox-text">Overwrite?</span>
            </label>
        </div>
        <small class="overwrite-disclaimer">Checking "Overwrite" will replace all existing files of this type. Leave unchecked to add to existing files.</small>
        {% endif %}
    </div>
    
    {% if help_text %}
        <small class="form-help">{{ help_text }}</small>
    {% endif %}

    {% if toggle %}
        <div class="toggle-help">
            <input type="checkbox" id="{{ name }}_toggle" onchange="document.getElementById('{{ name }}').disabled = !this.checked;">
            <label for="{{ name }}_toggle">Enable file upload</label>
        </div>
        <script>
            document.getElementById('{{ name }}').disabled = true;
        </script>
    {% endif %}
</div>
{% endmacro %}

{% macro websocket_upload_script(upload_endpoint="/ws/upload",
                                experiment_name_input_id="experiment_name",
                                upload_button_id="uploadButton", 
                                progress_container_id="progressContainer", 
                                status_messages_id="statusMessages", 
                                directory_input_id="directoryInput") %}
<script>
// Global variables for WebSocket upload state - ensure they're properly initialized
let selectedFiles = [];
let websocket = null;
let uploadId = null;
let directoryUploadCompleted = false;

// Debug logging function
function debugLog(message, data = null) {
    console.log(`[WebSocket Upload] ${message}`, data || '');
}



// Define protocol for WebSocket connection
const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';

// Generate unique upload ID
function generateUploadId() {
    return 'upload_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
}

// Handle directory selection (WebSocket upload only)
document.getElementById('{{ directory_input_id }}').addEventListener('change', function(event) {
    
    
    selectedFiles = Array.from(event.target.files);
    
    
    // Filter to only include image files
    const imageFiles = selectedFiles.filter(file => {
        const ext = file.name.split('.').pop().toLowerCase();
        return ['tif', 'tiff', 'png', 'jpg', 'jpeg'].includes(ext);
    });
    
    
    // filter files that are not included in a directory (those that do not have a relativepath )
    const dirFiles = imageFiles.filter(file => {
        return file.webkitRelativePath && file.webkitRelativePath !== file.name;
    });
    

    if (dirFiles.length !== selectedFiles.length) {
        const filteredCount = selectedFiles.length - dirFiles.length;
        addStatusMessage(`Note: ${filteredCount} non-directory/non-image files will be excluded from upload. Only directory files will be uploaded.`, 'warning');
        
    }
    
    selectedFiles = dirFiles;
    
    
    // Reset upload completion flag when new files are selected
    directoryUploadCompleted = false;
    
    
    displaySelectedFiles();
    
    // Store the raw image paths immediately when files are selected
    storeRawImagePaths(selectedFiles);
});

// Display selected files for directory upload
function displaySelectedFiles() {
    const fileList = document.getElementById('fileList');
    const totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);
    
    if (selectedFiles.length === 0) {
        fileList.style.display = 'none';
        return;
    }
    
    const fileListHTML = selectedFiles.slice(0, 20).map(file => 
        `<div class="file-item">${file.webkitRelativePath} (${formatFileSize(file.size)})</div>`
    ).join('');
    
    const additionalFiles = selectedFiles.length > 20 ? 
        `<div class="file-item"><em>... and ${selectedFiles.length - 20} more files</em></div>` : '';
    
    fileList.innerHTML = 
        `<strong>Selected files (${selectedFiles.length}) - Total: ${formatFileSize(totalSize)}:</strong><br>` +
        fileListHTML + additionalFiles;
    fileList.style.display = 'block';
}

// Format file size
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Add status message for directory upload
function addStatusMessage(message, type = 'info') {
    const statusDiv = document.getElementById('{{ status_messages_id }}');
    const messageDiv = document.createElement('div');
    messageDiv.className = `status ${type}`;
    messageDiv.textContent = message;
    statusDiv.appendChild(messageDiv);
    
    if (type === 'info' || type === 'warning') {
        setTimeout(() => {
            if (messageDiv.parentNode) {
                messageDiv.parentNode.removeChild(messageDiv);
            }
        }, 5000);
    }
}

// Start directory upload process
function startDirectoryUpload() {
    return new Promise((resolve, reject) => {
        
        
        const uploadNameInput = document.getElementById('experiment_name');
        const uploadName = uploadNameInput ? uploadNameInput.value.trim() : '';
    
        
        if (!uploadName) {
            const error = new Error('No experiment name');
            debugLog('Error: No experiment name');
            addStatusMessage('Please enter an experiment name before uploading directories.', 'error');
            reject(error);
            return;
        }
        
        if (selectedFiles.length === 0) {
            const error = new Error('No files selected');
            debugLog('Error: No files selected, selectedFiles.length:', selectedFiles.length);
            addStatusMessage('Please select directories to upload.', 'error');
            reject(error);
            return;
        }

        debugLog('Starting WebSocket upload for', selectedFiles.length, 'files');

        // Show progress container with enhanced visibility
        const progressContainer = document.getElementById('progressContainer');
        progressContainer.style.display = 'block';
        progressContainer.style.border = '2px solid #007bff';
        progressContainer.style.backgroundColor = '#f8f9fa';
        progressContainer.style.padding = '15px';
        progressContainer.style.borderRadius = '5px';
        progressContainer.style.marginTop = '10px';

        uploadId = generateUploadId();
        
        
        // Store upload ID for form submission
        let uploadIdInput = document.getElementById('websocket_upload_id');
        if (!uploadIdInput) {
            uploadIdInput = document.createElement('input');
            uploadIdInput.type = 'hidden';
            uploadIdInput.id = 'websocket_upload_id';
            uploadIdInput.name = 'websocket_upload_id';
            document.querySelector('form').appendChild(uploadIdInput);
        }
        uploadIdInput.value = uploadId;
        
        const overwriteCheckbox = document.querySelector('input[data-websocket-overwrite="true"]');
        const overwriteMode = overwriteCheckbox ? overwriteCheckbox.checked : false;
        
        
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/upload/${uploadId}?upload_name=${encodeURIComponent(uploadName)}&overwrite=${overwriteMode}`;
        
        // Close any existing WebSocket connection first
        if (websocket) {
            debugLog('Closing existing WebSocket connection');
            websocket.close();
            websocket = null;
        }
        
        websocket = new WebSocket(wsUrl);
        
        // Store resolve/reject functions for use in other handlers
        websocket._promiseResolve = resolve;
        websocket._promiseReject = reject;
        
        websocket.onopen = function() {
            addStatusMessage('Connected to server, starting directory upload...', 'info');
        };
        
        websocket.onmessage = async function(event) {
            const data = JSON.parse(event.data);
            
            switch(data.type) {
                case 'ready':
                    addStatusMessage('Server ready, uploading files...', 'info');
                    await uploadFiles();
                    break;
                
                case 'progress':
                    updateProgressImmediate(data);
                    break;
                
                case 'complete':
                    handleUploadComplete(data);
                    break;
                
                case 'error':
                    debugLog('Server error received:', data.message);
                    addStatusMessage(`Upload error: ${data.message}`, 'error');
                    resetUpload();
                    if (websocket._promiseReject) {
                        websocket._promiseReject(new Error(data.message));
                    }
                    break;
                    
                default:
                    debugLog('Unknown message type received:', data.type);
                    break;
            }
        };
        
        websocket.onerror = function(error) {
            debugLog('WebSocket error occurred:', error);
            addStatusMessage('WebSocket connection error', 'error');
            resetUpload();
            if (websocket._promiseReject) {
                websocket._promiseReject(new Error('WebSocket connection error'));
            }
        };
        
        websocket.onclose = function(event) {
            debugLog('WebSocket connection closed:', event.code, event.reason);
            debugLog('directoryUploadCompleted at close:', directoryUploadCompleted);
            
            if (!directoryUploadCompleted && event.code !== 1000) {
                debugLog('WebSocket closed unexpectedly, treating as error');
                addStatusMessage('WebSocket connection closed unexpectedly', 'error');
                resetUpload();
                if (websocket._promiseReject) {
                    websocket._promiseReject(new Error('WebSocket connection closed unexpectedly'));
                }
            } else {
                debugLog('WebSocket closed normally or upload already completed');
            }
        };
    });
}

/// Upload files via WebSocket
async function uploadFiles() {
    debugLog('=== uploadFiles called ===');
    debugLog('Files to upload:', selectedFiles.length);
    
    let uploadedCount = 0;
    let totalSize = 0;
    
    for (let i = 0; i < selectedFiles.length; i++) {
        const file = selectedFiles[i];
        debugLog(`Preparing file ${i + 1}/${selectedFiles.length}:`, file.webkitRelativePath);
        
        try {
            // Wait for server to be ready for next file
            await sendFileAndWaitForAck(file, i + 1, selectedFiles.length);
            
            uploadedCount++;
            totalSize += file.size;
            
            // Update progress immediately on client side
            updateProgressImmediate(uploadedCount, selectedFiles.length, totalSize, file.name);
            
        } catch (error) {
            debugLog(`Error uploading file ${file.name}:`, error.message);
            addStatusMessage(`Error uploading ${file.name}: ${error.message}`, 'error');
            throw error; // Stop upload on error
        }
    }
    
    // Send completion signal
    debugLog('Sending completion signal');
    if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(JSON.stringify({
            type: 'complete'
        }));
        debugLog('Completion signal sent');
    }
}

// New function to send file and wait for acknowledgment
function sendFileAndWaitForAck(file, fileNumber, totalFiles) {
    return new Promise(async (resolve, reject) => {
        const timeout = setTimeout(() => {
            reject(new Error(`Timeout waiting for acknowledgment of ${file.name}`));
        }, 30000); // 30 second timeout per file
        
        // Set up one-time message handler for this file
        const originalOnMessage = websocket.onmessage;
        websocket.onmessage = function(event) {
            const data = JSON.parse(event.data);
            
            if (data.type === 'file_received' || data.type === 'progress') {
                clearTimeout(timeout);
                websocket.onmessage = originalOnMessage; // Restore original handler
                resolve(data);
            } else {
                // Pass other messages to original handler
                originalOnMessage(event);
            }
        };
        
        try {
            const content = await fileToBase64(file);
            const message = {
                type: 'file',
                path: file.webkitRelativePath,
                content: content.split(',')[1], // Remove data:mime;base64, prefix
                file_number: fileNumber,
                total_files: totalFiles
            };
            
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify(message));
                debugLog(`Sent file ${fileNumber}: ${file.webkitRelativePath}`);
            } else {
                clearTimeout(timeout);
                websocket.onmessage = originalOnMessage;
                reject(new Error('WebSocket connection not available'));
            }
        } catch (error) {
            clearTimeout(timeout);
            websocket.onmessage = originalOnMessage;
            reject(error);
        }
    });
}

// New function for immediate progress updates
function updateProgressImmediate(filesUploaded, totalFiles, totalSize, currentFile) {
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    
    if (!progressFill || !progressText) return;
    
    const percentage = (filesUploaded / totalFiles) * 100;
    progressFill.style.width = `${percentage}%`;
    
    progressText.textContent = 
        `Uploaded ${filesUploaded} of ${totalFiles} files ` +
        `(${formatFileSize(totalSize)}) - Current: ${currentFile}`;
    
    debugLog(`Progress: ${filesUploaded}/${totalFiles} (${percentage.toFixed(1)}%)`);
}

// Convert file to base64
function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
    });
}


// Handle upload completion
function handleUploadComplete(data) {
    directoryUploadCompleted = true;
    
    document.getElementById('websocket_upload_completed').value = 'true';
    storeRawImagePaths(selectedFiles);
    
    addStatusMessage(`Upload completed! ${data.files_received} files (${formatFileSize(data.total_size)})`, 'success');
    
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    if (progressFill) progressFill.style.width = '100%';
    if (progressText) progressText.textContent = 'Upload completed!';
    
    if (websocket) {
        if (websocket._promiseResolve) websocket._promiseResolve(data);
        websocket.close(1000);
        websocket = null;
    }
}

// Reset upload state
function resetUpload() {
    const progressContainer = document.getElementById('progressContainer');
    progressContainer.style.display = 'none';
    // Reset enhanced styling
    progressContainer.style.border = '';
    progressContainer.style.backgroundColor = '';
    progressContainer.style.padding = '';
    progressContainer.style.borderRadius = '';
    progressContainer.style.marginTop = '';
    
    // Reset completion flags
    const completedInput = document.getElementById('websocket_upload_completed');
    if (completedInput) completedInput.value = 'false';
    
    directoryUploadCompleted = false;
    
    if (websocket) {
        websocket.close();
        websocket = null;
    }
}

// Store webkitRelativePath information for each file
function storeRawImagePaths(files) {
    const pathsData = [];
    files.forEach((file, index) => {
        if (file.webkitRelativePath) {
            pathsData.push({
                filename: file.name,
                relativePath: file.webkitRelativePath,
                index: index
            });
        }
    });
    
    console.log(`Storing paths for ${pathsData.length} files`);
    
    // Store in the hidden input field
    const pathsInput = document.getElementById('raw_image_paths');
    if (pathsInput) {
        const jsonData = JSON.stringify(pathsData);
        pathsInput.value = jsonData;
        console.log('Stored raw image paths:', pathsData);
    } else {
        console.error('Could not find raw_image_paths input field');
    }
}

// Store reference to original handleSubmit - this must be done AFTER the original is defined
let originalHandleSubmit = null;

// Function to capture the original handleSubmit once it's available
function captureOriginalHandleSubmit() {
    if (window.handleSubmit && window.handleSubmit !== customFormSubmissionHandler) {
        originalHandleSubmit = window.handleSubmit;
        debugLog('Captured original handleSubmit function');
        return true;
    }
    return false;
}

// Custom form submission handler function
async function customFormSubmissionHandler(event) {
    
    
    // First, try to capture the original handleSubmit if we haven't already
    if (!originalHandleSubmit) {
        captureOriginalHandleSubmit();
    }
    
    // Check if we have directory files to upload
    const hasDirectoryFiles = selectedFiles && selectedFiles.length > 0;
    debugLog('hasDirectoryFiles:', hasDirectoryFiles);
    debugLog('WebSocket upload condition:', hasDirectoryFiles && !directoryUploadCompleted);
    
    if (hasDirectoryFiles && !directoryUploadCompleted) {
        debugLog('=== Starting WebSocket upload process ===');
        
        // First run the original validation if it exists
        if (originalHandleSubmit) {
            debugLog('Running original form validation first...');
            const validationResult = originalHandleSubmit.call(event.target, event);
            debugLog('Original validation result:', validationResult);
            
            if (validationResult === false) {
                debugLog('Form validation failed, aborting WebSocket upload');
                return false;
            }
        }
        
        // Prevent normal form submission and start WebSocket upload first
        event.preventDefault();
        event.stopPropagation();
        
        // Disable the submit button to prevent multiple submissions
        const submitButton = document.getElementById('uploadButton');
        if (submitButton) {
            submitButton.disabled = true;
            submitButton.value = 'Uploading directories...';
            debugLog('Submit button disabled and text updated');
        }
        
        addStatusMessage('Starting directory upload, please wait...', 'info');
        
        try {
            debugLog('Calling startDirectoryUpload()...');
            await startDirectoryUpload();
            // After successful upload, submit the form normally
            debugLog('WebSocket upload completed successfully');
            addStatusMessage('Directory upload completed successfully!', 'success');
            
            // Re-enable submit button and change text
            if (submitButton) {
                submitButton.value = 'Submitting experiment...';
                debugLog('Submit button text updated to: Submitting experiment...');
            }
            
            // Wait a moment for user to see the success message, then submit
            setTimeout(() => {
                debugLog('Proceeding with normal form submission after WebSocket upload');
                
                // Submit the form directly, bypassing any submit handlers
                const form = event.target;
                debugLog('Submitting form directly to:', form.action);
                form.submit();
                
            }, 1500);
            
        } catch (error) {
            debugLog('WebSocket upload failed:', error.message);
            addStatusMessage(`Upload failed: ${error.message}`, 'error');
            
            // Re-enable submit button on error
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.value = 'Upload Experiment';
                debugLog('Submit button re-enabled after error');
            }
            return false;
        }
        
        return false; // Prevent immediate form submission
    }
    
    // No directory files or already uploaded, proceed with original validation and submission
    debugLog('=== Proceeding with normal form submission ===');
    debugLog('Reason: hasDirectoryFiles =', hasDirectoryFiles, ', directoryUploadCompleted =', directoryUploadCompleted);
    
    if (originalHandleSubmit) {
        debugLog('Calling original handleSubmit function for normal submission');
        return originalHandleSubmit.call(event.target, event);
    }
    
    debugLog('No original handleSubmit, allowing normal submission');
    return true;
}


// Set up the override - this must happen after DOM is loaded to ensure we capture the right function
document.addEventListener('DOMContentLoaded', function() {
    debugLog('DOM loaded, setting up form submission override');
    
    // Try to capture the original handleSubmit
    setTimeout(() => {
        if (captureOriginalHandleSubmit()) {
            debugLog('Setting up form submission override with captured original');
            window.handleSubmit = customFormSubmissionHandler;
        } else {
            debugLog('Could not capture original handleSubmit, setting up override anyway');
            window.handleSubmit = customFormSubmissionHandler;
        }
        
        // Also add direct event listener as backup
        const form = document.querySelector('form');
        if (form) {
            debugLog('Found form element, adding direct submit event listener as backup');
            form.addEventListener('submit', function(event) {
                debugLog('Direct form submit event triggered');
                // Only call our handler if the form doesn't already handle it
                if (!event.defaultPrevented) {
                    return customFormSubmissionHandler(event);
                }
            });
        }
    }, 100); // Small delay to ensure other scripts have loaded
});
</script>
{% endmacro %}