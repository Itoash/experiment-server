{% macro file_field_ws(name, label, help_text="", toggle=false, mode_toggle=false) %}
<div class="form-group">
    <div class="form-section directory-upload-container">
        <h2 style="text-align: center;">Upload Raw Images (Optional)</h2>
        <h3 style="text-align: center;">Upload raw image directories with either single-image TIFF files or Andor Spool files. Timestamps will be inferred from directory names/Andor metadata.</h3>
        
        
        
        <div class="file-input-container" id="dropZone">
            <p>Click to select directories or drag and drop them here</p>
            <input type="file" id="directoryInput" webkitdirectory multiple style="display: none;">
            <button type="button" class="upload-button" onclick="document.getElementById('directoryInput').click()">
                Select Directories
            </button>
        </div>
        
        <div id="fileList" class="file-list" style="display: none;"></div>
        
        <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <p id="progressText">Preparing upload...</p>
        </div>
        

        
        <div id="statusMessages"></div>
        
        {% if help_text %}
            <small class="form-help">{{ help_text }}</small>
        {% endif %}
        {% if mode_toggle %}
        
            
        <div class="overwrite-option">
            <label class="checkbox-label">
                <input type="checkbox" id="{{ name }}_overwrite" name="{{ name }}_mode" value="replace" data-websocket-overwrite="true">
                <span class="checkbox-text">Overwrite?</span>
            </label>
        </div>
        <small class="overwrite-disclaimer">Checking "Overwrite" will replace all existing files of this type. Leave unchecked to add to existing files.</small>
        {% endif %}
    </div>
    
    {% if help_text %}
        <small class="form-help">{{ help_text }}</small>
    {% endif %}

    {% if toggle %}
        <div class="toggle-help">
            <input type="checkbox" id="{{ name }}_toggle" onchange="document.getElementById('{{ name }}').disabled = !this.checked;">
            <label for="{{ name }}_toggle">Enable file upload</label>
        </div>
        <script>
            document.getElementById('{{ name }}').disabled = true;
        </script>
    {% endif %}
</div>
{% endmacro %}

{% macro websocket_upload_script(upload_endpoint="/ws/upload",
                                experiment_name_input_id="experiment_name",
                                upload_button_id="uploadButton", 
                                progress_container_id="progressContainer", 
                                status_messages_id="statusMessages", 
                                directory_input_id="directoryInput") %}
<script>
// Global variables for WebSocket upload state - ensure they're properly initialized
let selectedFiles = [];
let websockets = []; // Changed from single websocket to array
let uploadId = null;
let directoryUploadCompleted = false;
const MAX_CONCURRENT_CONNECTIONS = 4; // Configurable number of connections

// Debug logging function
function debugLog(message, data = null) {
    console.log(`[WebSocket Upload] ${message}`, data || '');
}



// Define protocol for WebSocket connection
const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';

// Generate unique upload ID
function generateUploadId() {
    return 'upload_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
}

// Handle directory selection (WebSocket upload only)
document.getElementById('{{ directory_input_id }}').addEventListener('change', function(event) {
    
    
    selectedFiles = Array.from(event.target.files);
    
    
    // Filter to only include image files
    const imageFiles = selectedFiles.filter(file => {
        const ext = file.name.split('.').pop().toLowerCase();
        return ['tif', 'tiff', 'png', 'jpg', 'jpeg'].includes(ext);
    });
    
    
    // filter files that are not included in a directory (those that do not have a relativepath )
    const dirFiles = imageFiles.filter(file => {
        return file.webkitRelativePath && file.webkitRelativePath !== file.name;
    });
    

    if (dirFiles.length !== selectedFiles.length) {
        const filteredCount = selectedFiles.length - dirFiles.length;
        addStatusMessage(`Note: ${filteredCount} non-directory/non-image files will be excluded from upload. Only directory files will be uploaded.`, 'warning');
        
    }
    
    selectedFiles = dirFiles;
    
    
    // Reset upload completion flag when new files are selected
    directoryUploadCompleted = false;
    
    
    displaySelectedFiles();
    
    // Store the raw image paths immediately when files are selected
    storeRawImagePaths(selectedFiles);
});

// Display selected files for directory upload
function displaySelectedFiles() {
    const fileList = document.getElementById('fileList');
    const totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);
    
    if (selectedFiles.length === 0) {
        fileList.style.display = 'none';
        return;
    }
    
    const fileListHTML = selectedFiles.slice(0, 20).map(file => 
        `<div class="file-item">${file.webkitRelativePath} (${formatFileSize(file.size)})</div>`
    ).join('');
    
    const additionalFiles = selectedFiles.length > 20 ? 
        `<div class="file-item"><em>... and ${selectedFiles.length - 20} more files</em></div>` : '';
    
    fileList.innerHTML = 
        `<strong>Selected files (${selectedFiles.length}) - Total: ${formatFileSize(totalSize)}:</strong><br>` +
        fileListHTML + additionalFiles;
    fileList.style.display = 'block';
}

// Format file size
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Add status message for directory upload
function addStatusMessage(message, type = 'info') {
    const statusDiv = document.getElementById('{{ status_messages_id }}');
    const messageDiv = document.createElement('div');
    messageDiv.className = `status ${type}`;
    messageDiv.textContent = message;
    statusDiv.appendChild(messageDiv);
    
    if (type === 'info' || type === 'warning') {
        setTimeout(() => {
            if (messageDiv.parentNode) {
                messageDiv.parentNode.removeChild(messageDiv);
            }
        }, 5000);
    }
}

// Start directory upload process with multiple connections
function startDirectoryUpload() {
    return new Promise((resolve, reject) => {
        const uploadNameInput = document.getElementById('experiment_name');
        const uploadName = uploadNameInput ? uploadNameInput.value.trim() : '';
    
        if (!uploadName) {
            const error = new Error('No experiment name');
            debugLog('Error: No experiment name');
            addStatusMessage('Please enter an experiment name before uploading directories.', 'error');
            reject(error);
            return;
        }
        
        if (selectedFiles.length === 0) {
            const error = new Error('No files selected');
            debugLog('Error: No files selected, selectedFiles.length:', selectedFiles.length);
            addStatusMessage('Please select directories to upload.', 'error');
            reject(error);
            return;
        }

        debugLog(`Starting WebSocket upload with ${MAX_CONCURRENT_CONNECTIONS} connections for ${selectedFiles.length} files`);

        // Show progress container
        const progressContainer = document.getElementById('progressContainer');
        progressContainer.style.display = 'block';
        progressContainer.style.border = '2px solid #007bff';
        progressContainer.style.backgroundColor = '#f8f9fa';
        progressContainer.style.padding = '15px';
        progressContainer.style.borderRadius = '5px';
        progressContainer.style.marginTop = '10px';

        uploadId = generateUploadId();
        
        // Store upload ID for form submission
        let uploadIdInput = document.getElementById('websocket_upload_id');
        if (!uploadIdInput) {
            uploadIdInput = document.createElement('input');
            uploadIdInput.type = 'hidden';
            uploadIdInput.id = 'websocket_upload_id';
            uploadIdInput.name = 'websocket_upload_id';
            document.querySelector('form').appendChild(uploadIdInput);
        }
        uploadIdInput.value = uploadId;
        
        const overwriteCheckbox = document.querySelector('input[data-websocket-overwrite="true"]');
        const overwriteMode = overwriteCheckbox ? overwriteCheckbox.checked : false;
        
        // Create multiple WebSocket connections
        createMultipleConnections(uploadName, overwriteMode, resolve, reject);
    });
}

// Create multiple WebSocket connections
function createMultipleConnections(uploadName, overwriteMode, resolve, reject) {
    // Close any existing connections
    closeAllConnections();
    
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    let connectionsReady = 0;
    let uploadStarted = false;
    
    // Create the specified number of connections
    for (let i = 0; i < MAX_CONCURRENT_CONNECTIONS; i++) {
        const wsUrl = `${protocol}//${window.location.host}/ws/upload/${uploadId}_${i}?upload_name=${encodeURIComponent(uploadName)}&overwrite=${overwriteMode}`;
        const ws = new WebSocket(wsUrl);
        
        ws.connectionId = i;
        ws._promiseResolve = resolve;
        ws._promiseReject = reject;
        
        ws.onopen = function() {
            debugLog(`Connection ${this.connectionId} opened`);
            addStatusMessage(`Connection ${this.connectionId + 1} established...`, 'info');
        };
        
        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            
            switch(data.type) {
                case 'ready':
                    connectionsReady++;
                    debugLog(`Connection ${this.connectionId} ready (${connectionsReady}/${MAX_CONCURRENT_CONNECTIONS})`);
                    
                    if (connectionsReady === MAX_CONCURRENT_CONNECTIONS && !uploadStarted) {
                        uploadStarted = true;
                        addStatusMessage('All connections ready, starting parallel upload...', 'info');
                        uploadFilesParallel();
                    }
                    break;
                
                case 'progress':
                case 'batch_received':
                    handleParallelProgress(data);
                    break;
                
                case 'complete':
                    handleConnectionComplete(this.connectionId, data);
                    break;
                
                case 'error':
                    debugLog(`Connection ${this.connectionId} error:`, data.message);
                    addStatusMessage(`Connection ${this.connectionId + 1} error: ${data.message}`, 'error');
                    closeAllConnections();
                    if (this._promiseReject) {
                        this._promiseReject(new Error(data.message));
                    }
                    break;
            }
        };
        
        ws.onerror = function(error) {
            debugLog(`Connection ${this.connectionId} error:`, error);
            addStatusMessage(`Connection ${this.connectionId + 1} error`, 'error');
            closeAllConnections();
            if (this._promiseReject) {
                this._promiseReject(new Error('WebSocket connection error'));
            }
        };
        
        ws.onclose = function(event) {
            debugLog(`Connection ${this.connectionId} closed:`, event.code, event.reason);
            if (!directoryUploadCompleted && event.code !== 1000) {
                debugLog(`Connection ${this.connectionId} closed unexpectedly`);
                if (!uploadStarted) {
                    addStatusMessage(`Connection ${this.connectionId + 1} closed unexpectedly`, 'error');
                    closeAllConnections();
                    if (this._promiseReject) {
                        this._promiseReject(new Error('WebSocket connection closed unexpectedly'));
                    }
                }
            }
        };
        
        websockets.push(ws);
    }
}
// Upload files in parallel across multiple connections
// Upload files in parallel across multiple connections - updated with better progress tracking
async function uploadFilesParallel() {
    debugLog('=== uploadFilesParallel called ===');
    debugLog('Files to upload:', selectedFiles.length);
    
    const BATCH_SIZE_LIMIT = 5 * 1024 * 1024; // 5MB batch limit
    const MAX_FILES_PER_BATCH = 10;

    // Reset progress tracker
    progressTracker.reset();
    progressTracker.totalFiles = selectedFiles.length;
    progressTracker.totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);

    // Create batches
    const batches = [];
    let currentBatch = [];
    let currentBatchSize = 0;
    
    for (let i = 0; i < selectedFiles.length; i++) {
        const file = selectedFiles[i];
        
        if ((currentBatchSize + file.size > BATCH_SIZE_LIMIT || 
             currentBatch.length >= MAX_FILES_PER_BATCH) && 
            currentBatch.length > 0) {
            batches.push(currentBatch);
            currentBatch = [];
            currentBatchSize = 0;
        }
        
        currentBatch.push(file);
        currentBatchSize += file.size;
    }
    
    if (currentBatch.length > 0) {
        batches.push(currentBatch);
    }
    
    progressTracker.totalBatches = batches.length;
    
    debugLog(`Uploading ${selectedFiles.length} files in ${batches.length} batches across ${websockets.length} connections`);
    
    // Initialize progress display
    updateProgressDisplay();
    
    // Distribute batches across connections
    const connectionPromises = [];
    
    for (let i = 0; i < websockets.length; i++) {
        const connectionBatches = batches.filter((_, batchIndex) => batchIndex % websockets.length === i);
        if (connectionBatches.length > 0) {
            connectionPromises.push(uploadBatchesOnConnection(websockets[i], connectionBatches, i));
        }
    }
    
    try {
        await Promise.all(connectionPromises);
        debugLog('All connections completed upload');
        
        // Send completion signal to all connections
        websockets.forEach((ws, index) => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'complete' }));
                debugLog(`Sent completion signal to connection ${index}`);
            }
        });
        
    } catch (error) {
        debugLog('Error in parallel upload:', error);
        throw error;
    }
}
// Upload batches on a specific connection
async function uploadBatchesOnConnection(ws, batches, connectionId) {
    debugLog(`Connection ${connectionId} uploading ${batches.length} batches`);
    
    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
        const batch = batches[batchIndex];
        
        try {
            await sendBatchOnConnection(ws, batch, batchIndex + 1, batches.length, connectionId);
            debugLog(`Connection ${connectionId} completed batch ${batchIndex + 1}`);
        } catch (error) {
            debugLog(`Connection ${connectionId} error on batch ${batchIndex + 1}:`, error);
            throw error;
        }
    }
}

// Send batch on specific connection - updated with better progress tracking
function sendBatchOnConnection(ws, files, batchNumber, totalBatches, connectionId) {
    return new Promise(async (resolve, reject) => {
        const timeout = setTimeout(() => {
            reject(new Error(`Connection ${connectionId} timeout on batch ${batchNumber}`));
        }, 60000);
        
        const originalOnMessage = ws.onmessage;
        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            
            if (data.type === 'batch_received' || data.type === 'progress') {
                clearTimeout(timeout);
                ws.onmessage = originalOnMessage;
                
                // Update progress tracker with this batch's completion
                const batchSize = files.reduce((sum, file) => sum + file.size, 0);
                progressTracker.updateConnectionProgress(connectionId, files.length, batchSize, batchNumber, totalBatches);
                updateProgressDisplay();
                
                resolve(data);
            } else {
                originalOnMessage(event);
            }
        };
        
        try {
            const batchFiles = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const content = await fileToBase64(file);
                batchFiles.push({
                    path: file.webkitRelativePath,
                    content: content.split(',')[1],
                    size: file.size,
                    name: file.name
                });
            }
            
            const message = {
                type: 'batch',
                files: batchFiles,
                batch_number: batchNumber,
                total_batches: totalBatches,
                connection_id: connectionId
            };
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
                debugLog(`Connection ${connectionId} sent batch ${batchNumber} with ${files.length} files`);
            } else {
                clearTimeout(timeout);
                ws.onmessage = originalOnMessage;
                reject(new Error('WebSocket connection not available'));
            }
        } catch (error) {
            clearTimeout(timeout);
            ws.onmessage = originalOnMessage;
            reject(error);
        }
    });
}

// Track progress across all connections - improved implementation
let progressTracker = {
    totalFiles: 0,
    totalBatches: 0,
    completedFiles: 0,
    completedBatches: 0,
    totalSize: 0,
    uploadedSize: 0,
    connectionProgress: {}, // Track per-connection progress
    reset: function() {
        this.totalFiles = 0;
        this.totalBatches = 0;
        this.completedFiles = 0;
        this.completedBatches = 0;
        this.totalSize = 0;
        this.uploadedSize = 0;
        this.connectionProgress = {};
    },
    updateConnectionProgress: function(connectionId, files, size, batchNumber, totalBatchesForConnection) {
        if (!this.connectionProgress[connectionId]) {
            this.connectionProgress[connectionId] = {
                completedFiles: 0,
                completedBatches: 0,
                totalBatches: totalBatchesForConnection,
                uploadedSize: 0
            };
        }
        
        this.connectionProgress[connectionId].completedFiles += files;
        this.connectionProgress[connectionId].completedBatches = batchNumber;
        this.connectionProgress[connectionId].uploadedSize += size;
        
        // Recalculate totals
        this.completedFiles = Object.values(this.connectionProgress)
            .reduce((sum, conn) => sum + conn.completedFiles, 0);
        this.completedBatches = Object.values(this.connectionProgress)
            .reduce((sum, conn) => sum + conn.completedBatches, 0);
        this.uploadedSize = Object.values(this.connectionProgress)
            .reduce((sum, conn) => sum + conn.uploadedSize, 0);
    },
    getProgress: function() {
        const fileProgress = this.totalFiles > 0 ? (this.completedFiles / this.totalFiles) * 100 : 0;
        const batchProgress = this.totalBatches > 0 ? (this.completedBatches / this.totalBatches) * 100 : 0;
        const sizeProgress = this.totalSize > 0 ? (this.uploadedSize / this.totalSize) * 100 : 0;
        
        // Use the most conservative progress estimate
        return Math.min(fileProgress, batchProgress, sizeProgress);
    }
};

// New unified progress display function
function updateProgressDisplay() {
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    
    if (!progressFill || !progressText) return;
    
    const percentage = progressTracker.getProgress();
    progressFill.style.width = `${Math.min(percentage, 100)}%`;
    
    // Create detailed progress text
    const connectionDetails = Object.entries(progressTracker.connectionProgress)
        .map(([id, progress]) => `Conn${parseInt(id) + 1}: ${progress.completedBatches}/${progress.totalBatches}`)
        .join(', ');
    
    progressText.innerHTML = `
        <div>Uploading ${progressTracker.completedFiles}/${progressTracker.totalFiles} files (${percentage.toFixed(1)}%)</div>
        <div>Size: ${formatFileSize(progressTracker.uploadedSize)}/${formatFileSize(progressTracker.totalSize)}</div>
        <div>Batches: ${progressTracker.completedBatches}/${progressTracker.totalBatches} | ${connectionDetails}</div>
    `;
    
    debugLog(`Progress: ${progressTracker.completedFiles}/${progressTracker.totalFiles} files (${percentage.toFixed(1)}%)`);
}

// Replace the old handleParallelProgress function
function handleParallelProgress(data) {
    // This function is called when we receive progress updates from the server
    // The main progress tracking is now handled in sendBatchOnConnection
    debugLog('Received progress update from server:', data);
    
    // If the server sends additional progress info, we can use it here
    if (data.connection_id !== undefined) {
        updateProgressDisplay();
    }
}






// Convert file to base64
function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
    });
}

// Update handleConnectionComplete to use the new progress tracker
function handleConnectionComplete(connectionId, data) {
    connectionsCompleted++;
    debugLog(`Connection ${connectionId} completed. ${connectionsCompleted}/${websockets.length} connections done.`);
    
    if (connectionsCompleted === websockets.length) {
        // All connections completed
        directoryUploadCompleted = true;
        
        document.getElementById('websocket_upload_completed').value = 'true';
        storeRawImagePaths(selectedFiles);
        
        addStatusMessage(`Upload completed! ${progressTracker.totalFiles} files (${formatFileSize(progressTracker.totalSize)}) uploaded via ${websockets.length} parallel connections.`, 'success');
        
        // Set progress to 100%
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        if (progressFill) progressFill.style.width = '100%';
        if (progressText) progressText.textContent = 'Upload completed successfully!';
        
        // Close all connections and resolve promise
        const resolve = websockets[0]._promiseResolve;
        closeAllConnections();
        if (resolve) resolve(data);
    }
}

// Update closeAllConnections to reset progress tracker
function closeAllConnections() {
    websockets.forEach((ws, index) => {
        if (ws) {
            debugLog(`Closing connection ${index}`);
            ws.close(1000);
        }
    });
    websockets = [];
    connectionsCompleted = 0;
    progressTracker.reset();
}


// Update resetUpload function to handle multiple connections
function resetUpload() {
    const progressContainer = document.getElementById('progressContainer');
    progressContainer.style.display = 'none';
    progressContainer.style.border = '';
    progressContainer.style.backgroundColor = '';
    progressContainer.style.padding = '';
    progressContainer.style.borderRadius = '';
    progressContainer.style.marginTop = '';
    
    const completedInput = document.getElementById('websocket_upload_completed');
    if (completedInput) completedInput.value = 'false';
    
    directoryUploadCompleted = false;
    
    closeAllConnections();
}

// Store webkitRelativePath information as a file instead of hidden input
function storeRawImagePaths(files) {
    const pathsData = [];
    files.forEach((file, index) => {
        if (file.webkitRelativePath) {
            pathsData.push({
                filename: file.name,
                relativePath: file.webkitRelativePath,
                index: index
            });
        }
    });
    
    console.log(`Storing paths for ${pathsData.length} files`);
    
    // Remove existing path inputs
    const existingInputs = document.querySelectorAll('input[name="raw_image_paths"]');
    existingInputs.forEach(input => input.remove());
    
    const form = document.querySelector('form');
    if (!form) {
        console.error('Could not find form element');
        return;
    }
    
    // Create JSON blob
    const jsonData = JSON.stringify(pathsData);
    const blob = new Blob([jsonData], { type: 'application/json' });
    
    console.log(`JSON data size: ${blob.size} bytes`);
    
    // Create a file input and populate it with the blob
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.name = 'raw_image_paths';
    fileInput.style.display = 'none'; // Hide the input
    
    // Create a DataTransfer object to set the file
    const dataTransfer = new DataTransfer();
    const file = new File([blob], 'raw_image_paths.json', { type: 'application/json' });
    dataTransfer.items.add(file);
    fileInput.files = dataTransfer.files;
    
    form.appendChild(fileInput);
    
    console.log('Stored raw image paths as file:', pathsData.length, 'entries');
}

// Store reference to original handleSubmit - this must be done AFTER the original is defined
let originalHandleSubmit = null;

// Function to capture the original handleSubmit once it's available
function captureOriginalHandleSubmit() {
    if (window.handleSubmit && window.handleSubmit !== customFormSubmissionHandler) {
        originalHandleSubmit = window.handleSubmit;
        debugLog('Captured original handleSubmit function');
        return true;
    }
    return false;
}

// Custom form submission handler function
async function customFormSubmissionHandler(event) {
    
    
    // First, try to capture the original handleSubmit if we haven't already
    if (!originalHandleSubmit) {
        captureOriginalHandleSubmit();
    }
    
    // Check if we have directory files to upload
    const hasDirectoryFiles = selectedFiles && selectedFiles.length > 0;
    debugLog('hasDirectoryFiles:', hasDirectoryFiles);
    debugLog('WebSocket upload condition:', hasDirectoryFiles && !directoryUploadCompleted);
    
    if (hasDirectoryFiles && !directoryUploadCompleted) {
        debugLog('=== Starting WebSocket upload process ===');
        
        // First run the original validation if it exists
        if (originalHandleSubmit) {
            debugLog('Running original form validation first...');
            const validationResult = originalHandleSubmit.call(event.target, event);
            debugLog('Original validation result:', validationResult);
            
            if (validationResult === false) {
                debugLog('Form validation failed, aborting WebSocket upload');
                return false;
            }
        }
        
        // Prevent normal form submission and start WebSocket upload first
        event.preventDefault();
        event.stopPropagation();
        
        // Disable the submit button to prevent multiple submissions
        const submitButton = document.getElementById('uploadButton');
        if (submitButton) {
            submitButton.disabled = true;
            submitButton.value = 'Uploading directories...';
            debugLog('Submit button disabled and text updated');
        }
        
        addStatusMessage('Starting directory upload, please wait...', 'info');
        
        try {
            debugLog('Calling startDirectoryUpload()...');
            await startDirectoryUpload();
            // After successful upload, submit the form normally
            debugLog('WebSocket upload completed successfully');
            addStatusMessage('Directory upload completed successfully!', 'success');
            
            // Re-enable submit button and change text
            if (submitButton) {
                submitButton.value = 'Submitting experiment...';
                debugLog('Submit button text updated to: Submitting experiment...');
            }
            
            // Wait a moment for user to see the success message, then submit
            setTimeout(() => {
                debugLog('Proceeding with normal form submission after WebSocket upload');
                
                // Submit the form directly, bypassing any submit handlers
                const form = event.target;
                debugLog('Submitting form directly to:', form.action);
                form.submit();
                
            }, 1500);
            
        } catch (error) {
            debugLog('WebSocket upload failed:', error.message);
            addStatusMessage(`Upload failed: ${error.message}`, 'error');
            
            // Re-enable submit button on error
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.value = 'Upload Experiment';
                debugLog('Submit button re-enabled after error');
            }
            return false;
        }
        
        return false; // Prevent immediate form submission
    }
    
    // No directory files or already uploaded, proceed with original validation and submission
    debugLog('=== Proceeding with normal form submission ===');
    debugLog('Reason: hasDirectoryFiles =', hasDirectoryFiles, ', directoryUploadCompleted =', directoryUploadCompleted);
    
    if (originalHandleSubmit) {
        debugLog('Calling original handleSubmit function for normal submission');
        return originalHandleSubmit.call(event.target, event);
    }
    
    debugLog('No original handleSubmit, allowing normal submission');
    return true;
}


// Set up the override - this must happen after DOM is loaded to ensure we capture the right function
document.addEventListener('DOMContentLoaded', function() {
    debugLog('DOM loaded, setting up form submission override');
    
    // Try to capture the original handleSubmit
    setTimeout(() => {
        if (captureOriginalHandleSubmit()) {
            debugLog('Setting up form submission override with captured original');
            window.handleSubmit = customFormSubmissionHandler;
        } else {
            debugLog('Could not capture original handleSubmit, setting up override anyway');
            window.handleSubmit = customFormSubmissionHandler;
        }
        
        // Also add direct event listener as backup
        const form = document.querySelector('form');
        if (form) {
            debugLog('Found form element, adding direct submit event listener as backup');
            form.addEventListener('submit', function(event) {
                debugLog('Direct form submit event triggered');
                // Only call our handler if the form doesn't already handle it
                if (!event.defaultPrevented) {
                    return customFormSubmissionHandler(event);
                }
            });
        }
    }, 100); // Small delay to ensure other scripts have loaded
});
</script>
{% endmacro %}